Домашние задания Машаев Роман



В этом репозитории расположены ваши домашние задания к каждой лекции. 

Обязательными к выполнению являются задачи без указания звёздочки. Их выполнение необходимо для получения зачёта и диплома о профессиональной переподготовке.

Задачи со звёздочкой (*) являются дополнительными задачами или задачами повышенной сложности. Они не обязательны к выполнению, но помогут вам глубже понять тему.

Любые вопросы по решению задач задавайте в чате учебной группы, ссылку вы найдёте в письме на вашей электронной почте.

Модуль «Системы хранения и передачи данных

1. [Базы данных, их типы](https://github.com/netology-code/sdb-homeworks/blob/main/11-01.md).

ОТВЕТЫ на Задание 1:
1.1. Бюджетирование проектов, финансовые отчёты и прогнозирование рисков
Рекомендуемый тип СУБД: Реляционная (SQL) СУБД. Так как:
- Чёткая структура и целостность данных: Реляционные СУБД (PostgreSQL, MySQL, Microsoft SQL
Server, Oracle) идеально подходят для финансовых данных, где важна жёсткая схема,
 предопределённые связи (проекты - статьи бюджета - фактические затраты) и гарантированная
 целостность благодаря механизмам ACID (транзакционность). Это исключает ошибки и потери
 данных при операциях.
- Сложные запросы и аналитика: Формирование отчётов и прогнозирование требует агрегации 
данных, соединения множества таблиц и использования оконных функций. SQL идеально
 оптимизирован для таких операций.
 - Прогнозирование: Для задач прогнозирования рисков часто используются хранилища данных,
 которые строятся на основе реляционных моделей (звёздная или снежинка).
 Данные из операционной СУБД можно преобразовать и загрузить в хранилище данных для
 глубокого анализа.

1.1. Хеширование стало занимать много времени. Какой API можно использовать
 для ускорения работы?*
Проблема с хешированием на уровне приложения говорит о высокой нагрузке.
 Решение заключается в переносе этой операции на уровень СУБД.
- Использовать встроенные функции СУБД: Например, в PostgreSQL есть функция crypt из
 расширения pgcrypto. Вычисление хеша прямо в запросе эффективнее, так как СУБД
 оптимизирована для пакетных операций и не требует передачи данных туда-обратно в приложение.
-    Использовать API базы данных, а не внешний сервис: Перенос логики в СУБД — это и есть
 использование её API (набор функций и операторов SQL). Это самый эффективный способ.
 Применение внешнего API только добавит сетевую задержку и усложнит архитектуру.

1.2. Лендинги и CRM-система
Рекомендуемый тип СУБД:
Для лендингов: Документоориентированная NoSQL СУБД (например, MongoDB).
Для CRM-системы: Реляционная (SQL) СУБД (например, PostgreSQL).
- Лендинги: требуют гибкости. Структура данных, собираемых с формы (имя, e-mail, телефон,
 выбранная квартира, комментарий), может часто меняться. NoSQL-базы не требуют жёсткой
 схемы, что позволяет быстро добавлять новые поля без изменения структуры базы и
 простоев.
 Они также показывают высокую скорость записи и масштабируются для обработки пиковых
 нагрузок (например, во время рекламной кампании).
- CRM-система: Требует структурированности, целостности и сложных запросов. Данные о
 клиентах, сделках, взаимодействиях, задачах менеджеров имеют сложные связи.
 Реляционная СУБД гарантирует, что не будет сделки без клиента или дубликатов контактов,
 и позволяет  строить эффективные выборки для отчётов по менеджерам и источникам лидов.

1.2. Можно ли решить эту задачу с помощью одной СУБД?*
Да, это возможно. Современные СУБД стирают границы между типами.
Оптимальный кандидат — PostgreSQL. Она является гибридной СУБД:
Она мощная реляционная СУБД, идеальная для CRM.
Она поддерживает JSONB-тип данных, который позволяет хранить и индексировать
документы NoSQL-стиле. Данные с лендингов можно сразу сохранять в виде JSON-объекта в таблицу
leads, что даёт необходимую гибкость. При этом все данные находятся в одной системе,
 что упрощает управление и интеграцию.

1.3. База корпоративных норм, правил и учебных материалов (База Знаний)
Рекомендуемый тип СУБД: Реляционная СУБД.
Почему? Требование "простой и понятной структуры" говорит о том, что данные хорошо
 структурируются. Это иерархическая информация: разделы - подразделы - документы.
 Реляционная база отлично справляется с хранением деревьев  (например, с помощью метода
 «Вложенных множеств» или «Материализованных путей»). Альтернативой может быть использование
 графовой СУБД, но это избыточно для такой задачи.

1.3. Можно ли использовать уже существующую СУБД?*
 Да. Лучше всего использовать ту же реляционную СУБД (например, PostgreSQL), что и
 для бюджетирования или CRM.  Создать в общей базе данных или в отдельной схеме таблицы.
 Это обеспечит целостность (нельзя удалить раздел с документами),
 простоту организации и лёгкость интеграции. Например, учебные материалы можно привязывать
 к проектам  или финансовым статьям.

1.4. Задачи логистики (маршруты доставки, распределение курьеров)
Рекомендуемый тип СУБД: Графовая СУБД.
Ключевая фраза — «быстро работать со связями». Задачи маршрутизации — это классическая
 область применения графовых баз (Neo4j, Amazon Neptune).
-   Объекты: Склады, объекты строительства, курьеры — это узлы графа.
-  Связи: Дороги между объектами (с атрибутами: расстояние, время проезда,
 платные участки) — это рёбра. 
-  Запросы: Поиск кратчайшего пути, оптимизация маршрута с несколькими точками — это
 нативные запросы для графовой СУБД, которые выполняются на порядки быстрее, чем аналогичные
 запросы на SQL.

1.4. Можно ли подключить отдел закупок?*
Да. Логистика и закупки тесно связаны. Закупки заказывают материалы, а логистика их
 доставляет.
- Не создавать отдельную СУБД, а интегрироваться. Данные о закупленных материалах, их
 объёмах, сроках и точках доставки должны храниться в реляционной СУБД (закупки — это учёт,
 заказы, финансы). Отдел логистики должен иметь доступ к этим данным.
 Данные из реляционной СУБД закупок синхронизируются с графовой СУБД логистики. В графовую
 базу  попадают узлы «Объект X, требует Y тонн материалов к дате Z". Алгоритм маршрутизации
 использует эти данные для построения оптимальных путей»

1.5. Можно ли решить все задачи с помощью одной СУБД?*
Теоретически — да, на современной гибридной СУБД.
Но, все же, использовать одну СУБД для всего — плохая идея. Это усложняет масштабирование
и заставляет использовать инструмент не по его основному назначению.
Правильнее — использовать нескольких специализированных СУБД, каждая из которых лучше
 всего решает свою задачу:
1.Финансы, CRM, База знаний: Реляционная СУБД (PostgreSQL).
2.Лендинги: Документоориентированная NoSQL (MongoDB) или JSONB в PostgreSQL.
3.Логистика: Графовая СУБД.

ОТВЕТЫ на Задание 2

2.1. Стандартное пополнение счёта телефона:
1.Инициация транзакции. Пользователь вводит номер телефона и сумму пополнения в интерфейсе
 приложения банка, платежного терминала или на сайте оператора связи и подтверждает
 операцию (например, нажатием кнопки «Оплатить»).
2.Аутентификация и авторизация. Платежная система (банк, процессинговый центр) запрашивает
 у пользователя подтверждение его личности и прав на совершение операции. Это может
 быть ввод SMS-кода, пароля из push-уведомления, сканер отпечатка пальца или Face ID.
 Система проверяет, действителен ли этот код/биометрия и не превышены ли лимиты.
3.Проверка баланса плательщика. Банк-эквайер (банк, который обслуживает терминал или
 приложение) или процессинговый центр проверяет, достаточно ли средств на счете/карте
 пользователя для списания нужной суммы (с учетом возможной комиссии).
4.Списание средств и запрос к оператору. Если средства есть, банк блокирует или сразу
 списывает сумму со счета пользователя. Далее платежный шлюз банка формирует специальный
 запрос (обычно по протоколу API) к биллинговой системе оператора связи на зачисление 
средств на указанный номер телефона.
5.Зачисление средств и подтверждение. Биллинговая система оператора связи принимает
 запрос, проверяет его корректность и зачисляет указанную сумму на баланс целевого номера.
 После успешного зачисления система отправляет электронный чек или подтверждение обратно
 в платежную систему банка.
6.Финальное подтверждение пользователю. Банк получает подтверждение от оператора, завершает
 транзакцию на своей стороне и отправляет пользователю окончательное подтверждение
 об успешном пополнении (сообщение в приложении, SMS-чек). Параллельно оператор связи
 также обычно отправляет пользователю SMS о пополнении баланса.

2.1.* Пополнение через автоплатёж
В этом случае процесс автоматизирован, но включает дополнительные этапы настройки и проверок.
Этап настройки (происходит один раз):
•Подписание соглашения. Пользователь в приложении банка или оператора связывает свой номер
 телефона с банковской картой/счетом и дает согласие на автоматическое списание
 средств по заданному условию (например, «каждый месяц 25 числа» или «при снижении баланса
 ниже 50 рублей»). Подписывается электронное соглашение о recurring payments
 (регулярных платежах).
Этап выполнения каждого автоплатежа:
1.Срабатывание триггера. Биллинговая система банка в установленную дату или при получении
 от оператора связи запроса (в случае автопополнения по низкому балансу) инициирует
 новый платеж.
2.Авторизация и проверка средств. Банк автоматически проверяет, достаточно ли средств на
 привязанной карте, и проводит авторизацию. Важный нюанс: так как пользователь физически
 не присутствует (это транзакция без его участия - MIT, Merchant Initiated Transaction),
 банк не запрашивает у него CVV-код или SMS, а использует ранее выданное согласие и
 специальный токен (ключ), сгенерированный при привязке карты.
3.Списание и запрос. Банк списывает средства и отправляет запрос в биллинговую систему
 оператора связи на пополнение счета.
4.Зачисление и уведомление. Оператор связи зачисляет деньги на счет и отправляет
 подтверждение банку. Банк, в свою очередь, отправляет пользователю уведомление о
 successful autopayment (успешном автоплатеже) — например, push-уведомление или email.
 Оператор также может отправить стандартное SMS о пополнении.
Ключевое отличие: Основная разница в отсутствии действий пользователя для каждого
 конкретного платежа (шаги 1 и 2 из первого списка). Вся авторизация основана на
 предварительно данном согласии и привязке карты по токену, что делает процесс автоматическим.
 

ОТВЕТ на Задание 3

Пять преимуществ SQL-систем по отношению к NoSQL
1.Гарантированная целостность данных (ACID). Это ключевое преимущество реляционных СУБД.
Транзакции в SQL гарантированно выполняются по принципу "Все или ничего" (Atomicity),
переводят данные из одного целостного состояния в другое (Consistency), изолированы от
других транзакций (Isolation) и результаты их выполнения устойчивы (Durability).
Это критически важно для финансовых систем, банковских операций, любых приложений, где
ошибка или потеря данных недопустимы.

2.Универсальный и мощный язык запросов (SQL). SQL — это стандартизированный, декларативный
и очень выразительный язык. Пользователь описывает что он хочет получить, а не как это
сделать. СУБД сама строит оптимальный план выполнения сложных запросов с джойнами (JOIN),
агрегациями, вложенными подзапросами и т.д. В NoSQL-системах запросы часто ограничены и
специфичны для конкретной модели данных.

3.Гибкость запросов и сложная аналитика. Благодаря схеме данных и поддержке операций JOIN 
реляционные базы данных идеально подходят для выполнения ad-hoc запросов — тех, которые 
заранее неизвестны и формулируются по мере необходимости для анализа данных. Соединение 
данных из множества таблиц для получения комплексной отчетности — сильная сторона SQL.

4.Стандартизация и зрелость экосистемы. Реляционные базы данных существуют десятилетиями, 
что привело к созданию огромного количества инструментов, библиотек, ORM (Hibernate, Django 
ОRM), систем мониторинга и управления. SQL является стандартом (с диалектами), что
позволяет разработчикам relatively легко переходить между различными SQL-системами
(PostgreSQL, MySQL, Oracle).

5.Нормализация данных и отсутствие дублирования. Реляционная модель поощряет нормализацию 
данных — процесс организации данных для минимизации избыточности. Это позволяет хранить 
каждую единицу информации в одном месте, что упрощает ее обновление и обеспечивает 
консистентность. В NoSQL (особенно в документных) данные часто денормализованы и 
дублируются для скорости чтения, что усложняет их обновление.


3.1. Преимущества NewSQL систем перед SQL и NoSQL*
NewSQL — это современный класс систем управления базами данных, который сочетает в себе 
преимущества классических SQL-систем и горизонтальной масштабируемости NoSQL.

Преимущества перед традиционными SQL-системами:
-Горизонтальная масштабируемость (Sharding). Классические SQL-базы (как MySQL или 
PostgreSQL в single-master архитектуре) плохо масштабируются на запись. NewSQL-системы 
(например, Google Spanner, CockroachDB, TiDB) изначально проектировались как 
распределеннысистемы. Они автоматически шардируют данные across many nodes, обеспечивая 
линейное масштабирование производительности как на чтение, так и на запись.
-Высокая доступность и отказоустойчивость. Распределенная архитектура NewSQL подразумевает 
репликацию данных среди множества нод и дата-центров. При выходе из строя одного или даже 
нескольких узлов система продолжает работать практически без простоя, обеспечивая высокий 
uptime.

Преимущества перед NoSQL-системами:
•Полная поддержка ACID-транзакций и SQL. Главный компромисс NoSQL — ослабление или отказ от
ACID-гарантий (модель BASE) и полноценного SQL в угоду масштабируемости. NewSQL убирает
этот компромисс. Они предоставляют тот же уровень согласованности данных и мощный 
SQL-интерфейс, что и реляционные базы, но на распределенной архитектуре.
•Единый взгляд на данные (Strong Consistency). В распределенных NoSQL-системах 
(например, Cassandra) часто используется eventual consistency, что означает, что некоторые 
узлы базы могут временно показывать устаревшие данные. NewSQL-системы, как правило, 
обеспечивают strong consistency, что означает, что любой клиент, обращающийся к базе, 
всегда видит самое актуальное значение данных.

  Итог: NewSQL предлагает «лучшее из двух миров»: масштабируемость и отказоустойчивость 
NoSQL без потери гарантий целостности данных (ACID) и мощности SQL, присущих традиционным 
реляционным СУБД. Это делает их идеальным выбором для высоконагруженных OLTP-приложений, 
которым критически важны и масштаб, и точность данных (например, финансовые сервисы, 
глобальные платформы электронной коммерции).

ОТВЕТ на Задание 4

Критерий выбора типа СУБД
Ключевой критерий, на основе которого нужно выбирать тип СУБД — характер выполняемых 
операций и требований к данным. Чтобы его определить, необходимо ответить на вопросы:
Что это за вычисления? Это аналитические запросы (агрегация, JOIN больших таблиц,
построение отчётов) или оперативные транзакции (добавление, изменение, точечные запросы)? 
Что это за данные? Данные в основном структурированные (таблицы с чёткими схемами),
полуструктурированные (JSON, документы) или неструктурированные?
Каковы требования к согласованности? Допустима ли eventual consistency ( eventual
consistency) или всегда требуется строгая согласованность (strong consistency)? Например,
для финансовых операций нужна строгая согласованность, а для подсчёта лайков в соцсети — нет.
На основе этого формируются два основных сценария:

Сценарий А: Обработка транзакций (OLTP - Online Transaction Processing) Если вычисления
включают много коротких операций записи и чтения, требующих строгой согласованности 
(например, обновление баланса пользователя, обработка заказов), то целесообразно 
использовать тип СУБД: распределённые NewSQL или транзакционные NoSQL СУБД. Примеры: 
Google panner, YugabyteDB, CockroachDB, Amazon Aurora. Из NoSQL — Cassandra (с настройкой 
уровня огласованности), MongoDB (шардированные кластеры).
Эти системы сочетают горизонтальную масштабируемость (шардирование) с поддержкой транзакций
 CID (или их части) и SQL-синтаксиса (кроме NoSQL).

Сценарий Б: Аналитическая обработка (OLAP - Online Analytical Processing)
Если вычисления — это сложные аналитические запросы, сканирование и агрегация petabytes
данных, построение дашбордов и ML-моделей (наиболее вероятный сценарий для формулировки 
"большое количество вычислений при работе с огромным количеством данных"). Здесь лучше 
использовать тип СУБД - колоночные распределённые СУБД. Например: ClickHouse, Apache Druid,
Greenplum, Vertica, BigQuery, Snowflake.
Основания:
Колоночное хранение: Позволяет читать только нужные для агрегации столбцы, а не всю строку,
что drastically сокращает объём I/O операций. Данные в одном столбце имеют схожий тип, что 
позволяет сжимать их очень эффективно. Система автоматически распараллеливает один запрос 
на все узлы кластера.


2. Модель распределённых вычислений
Для задачи аналитики (OLAP), которая лучше всего ложится на кластер из 1000 машин, лучше 
всего справится модель MPP (Massively Parallel Processing — массовый параллельный обработчик).

1.Каждая машина (узел) в кластере имеет собственные процессор, память и диски. Ничем не 
делится с другими узлами. Это делает систему идеально масштабируемой горизонтально — чтобы 
увеличить мощность, нужно просто добавить ещё одну машину. Для 1000 машин это критически 
важно.
2.Когда поступает сложный аналитический запрос координатор (master node) разбивает его на 
множество независимых подзадач. Каждая подзадача выполняется на своем узле или группе 
узлов, обрабатывая свой кусок данных (shard). Затем результаты со всех узлов агрегируются и
возвращаются пользователю (параллельное выполнение запроса)
3.Высокая производительность на больших данных: MPP-системы оптимизированы для полного 
сканирования огромных таблиц и их агрегации, а не для точечных операций. 1000 машин 
одновременно будут обрабатывать разные части одного запроса, что дает колоссальную скорость.


Таким образом критерий выбора СУБД определяется тем, являются ли вычисления оперативными 
(OLTP) или аналитическими (OLAP). Для формулировки «огромное количество данных» и «большое 
количество вычислений» наиболее вероятен сценарий OLAP.
В данном случае препочтительным решением будет использование распределённой колоночной MPP-
СУБД с моделью вычислений- MPP (Massively Parallel Processing).
MPL-архитектура идеально использует вычислительную мощность всех 1000 машин, 
распараллеливая каждый аналитический запрос. Колоночное хранение обеспечивает максимальную 
скорость выполнения агрегирующих запросов и эффективное использование дискового 
пространства за счёт сжатия. Это специализированный инструмент под задачу быстро посчитать 
что-то по огромному массиву данных.










2. [Кеширование Redis/memcached](https://github.com/netology-code/sdb-homeworks/blob/main/11-02.md).

3. [ELK](https://github.com/netology-code/sdb-homeworks/blob/main/11-03.md).

4. [Очереди RabbitMQ](https://github.com/netology-code/sdb-homeworks/blob/main/11-04.md).


## Модуль «Реляционные базы данных и администрирование баз данных»

1. [Базы данных](https://github.com/netology-code/sdb-homeworks/blob/main/12-01.md).

2. [Работа с данными (DDL/DML)](https://github.com/netology-code/sdb-homeworks/blob/main/12-02.md).

3. [SQL. Часть 1](https://github.com/netology-code/sdb-homeworks/blob/main/12-03.md).

4. [SQL. Часть 2](https://github.com/netology-code/sdb-homeworks/blob/main/12-04.md).

5. [Индексы](https://github.com/netology-code/sdb-homeworks/blob/main/12-05.md).

6. [Репликация и масштабирование. Часть 1](https://github.com/netology-code/sdb-homeworks/blob/main/12-06.md).

7. [Репликация и масштабирование. Часть 2](https://github.com/netology-code/sdb-homeworks/blob/main/12-07.md).

8. [Резервное копирование](https://github.com/netology-code/sdb-homeworks/blob/main/12-08.md).

9. [Базы данных в облаке](https://github.com/netology-code/sdb-homeworks/blob/main/12-09.md).


## Модуль «Информационная безопасность»

1. [Уязвимости и атаки на информационные системы](https://github.com/netology-code/sdb-homeworks/blob/main/13-01.md).

2. [Защита хоста](https://github.com/netology-code/sdb-homeworks/blob/main/13-02.md).

3. [Защита сети](https://github.com/netology-code/sdb-homeworks/blob/main/13-03.md).

4. [Best practices современной информационной безопасности]().

